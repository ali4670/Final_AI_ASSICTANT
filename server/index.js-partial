import './validate-env.js';
import express from 'express';
import cors from 'cors';
import Groq from 'groq-sdk';
import OpenAI from 'openai';
import dotenv from 'dotenv';
import { createClient } from '@supabase/supabase-js';
import { connectDB } from './db.js';
import StudyProfile from './models/Study.js';
import fs from 'fs';
import path from 'path';
import SpotifyWebApi from 'spotify-web-api-node';

dotenv.config();

// Connect to MongoDB
connectDB();

const app = express();

app.use(cors());
app.use(express.json({ limit: '50mb' }));

let GROQ_API_KEY = process.env.GROQ_API_KEY || process.env.VITE_GROQ_API_KEY;
let OPENAI_API_KEY = process.env.OPENAI_API_KEY;
let SPOTIFY_CLIENT_ID = process.env.SPOTIFY_CLIENT_ID;
let SPOTIFY_CLIENT_SECRET = process.env.SPOTIFY_CLIENT_SECRET;
const SUPABASE_URL = process.env.SUPABASE_URL || process.env.VITE_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

const supabase = (SUPABASE_URL && SUPABASE_SERVICE_ROLE_KEY) 
    ? createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY) 
    : null;

let groq = new Groq({ apiKey: GROQ_API_KEY || 'MISSING_KEY' });
let openai = OPENAI_API_KEY ? new OpenAI({ apiKey: OPENAI_API_KEY }) : null;
let spotifyApi = new SpotifyWebApi({
    clientId: SPOTIFY_CLIENT_ID,
    clientSecret: SPOTIFY_CLIENT_SECRET,
    redirectUri: process.env.SPOTIFY_REDIRECT_URI || 'http://localhost:5173/callback',
});

// Helper for JSON repair
const repairJSON = (str) => {
    let json = str.trim();
    if (json.startsWith('```json')) json = json.replace(/```json/g, '').replace(/```/g, '').trim();
    
    // Fix unterminated string
    let openQuotes = 0;
    for (let i = 0; i < json.length; i++) {
        if (json[i] === '"' && json[i-1] !== '') openQuotes++;
    }
    if (openQuotes % 2 !== 0) json += '"';

    // Fix missing brackets
    const stack = [];
    for (let i = 0; i < json.length; i++) {
        if (json[i] === '{') stack.push('}');
        else if (json[i] === '[') stack.push(']');
        else if (json[i] === '}' || json[i] === ']') {
            if (stack.length > 0 && stack[stack.length - 1] === json[i]) {
                stack.pop();
            }
        }
    }
    while (stack.length > 0) {
        json += stack.pop();
    }
    return json;
};

// Function to load settings from Supabase
const loadSettings = async () => {
    if (!supabase) return;
    try {
        const { data: settings, error } = await supabase.from('system_settings').select('*');
        if (error) throw error;

        settings.forEach(setting => {
            if (setting.value) {
                if (setting.key === 'GROQ_API_KEY') {
                    GROQ_API_KEY = setting.value;
                    groq = new Groq({ apiKey: GROQ_API_KEY });
                }
                if (setting.key === 'OPENAI_API_KEY') {
                    OPENAI_API_KEY = setting.value;
                    openai = new OpenAI({ apiKey: OPENAI_API_KEY });
                }
                if (setting.key === 'SPOTIFY_CLIENT_ID') {
                    SPOTIFY_CLIENT_ID = setting.value;
                    spotifyApi.setClientId(SPOTIFY_CLIENT_ID);
                }
                if (setting.key === 'SPOTIFY_CLIENT_SECRET') {
                    SPOTIFY_CLIENT_SECRET = setting.value;
                    spotifyApi.setClientSecret(SPOTIFY_CLIENT_SECRET);
                }
            }
        });
        console.log("✅ System settings loaded from Supabase");
    } catch (err) {
        console.error("❌ Failed to load settings from Supabase:", err.message);
    }
};

// Initial load
loadSettings();

// Admin: Reload Config
app.post('/api/admin/reload-config', async (req, res) => {
    const { adminId } = req.body;
    if (!supabase) return res.status(503).json({ error: "Supabase not configured" });

    try {
        const { data: adminProfile } = await supabase.from('profiles').select('is_admin').eq('id', adminId).single();
        if (!adminProfile?.is_admin) return res.status(403).json({ error: "Forbidden" });

        await loadSettings();
        res.json({ success: true, message: "Configuration reloaded" });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// --- GENERATE NEURAL SUMMARY ---
app.post('/api/generate-neural-summary', async (req, res) => {
    const { documentContent, title, documentId, userId } = req.body;
    
    try {
        const prompt = `Based on the document titled "${title}", create a comprehensive "Neural Summary".
        The response must be a SINGLE JSON object with the following structure:
        {
          "summary": "A deep, structured markdown summary with headings, bullet points, and key takeaways.",
          "quiz": [
            {"question": "...", "options": ["...", "...", "...", "..."], "answer": "...", "explanation": "..."}
          ],
          "exam": [
            {"question": "...", "type": "multiple-choice", "options": ["...", "...", "...", "..."], "answer": "..."},
            {"question": "...", "type": "true-false", "answer": "True/False"}
          ]
        }
        
        Generate 5 quiz questions and 5 exam questions.
        Return ONLY the raw JSON. No markdown code blocks.

        Document Content:
        ${documentContent.slice(0, 20000)}`;

        const completion = await groq.chat.completions.create({
            messages: [
                { role: "system", content: "You are a specialized academic AI. You provide deep synthesis and structured JSON outputs." },
                { role: "user", content: prompt }
            ],
            model: "llama-3.3-70b-versatile",
            temperature: 0.4,
            max_tokens: 8192,
        });

        let responseText = completion.choices[0]?.message?.content || "{}";
        
        const extractJSON = (text) => {
            try {
                return JSON.parse(text.replace(/```json/g, '').replace(/```/g, '').trim());
            } catch (e) {
                try {
                    const repaired = repairJSON(text);
                    return JSON.parse(repaired);
                } catch (repairError) {
                    const start = text.indexOf('{');
                    const end = text.lastIndexOf('}');
                    if (start !== -1 && end !== -1) {
                        try {
                            return JSON.parse(text.substring(start, end + 1));
                        } catch (innerE) {
                            throw new Error("JSON structure is incomplete.");
                        }
                    }
                    throw repairError;
                }
            }
        };

        const data = extractJSON(responseText);
        
        if (supabase && userId && documentId) {
            await supabase.from('neural_summaries').insert([{
                user_id: userId,
                document_id: documentId,
                title: `Neural Summary: ${title}`,
                summary_text: data.summary,
                quiz_data: data.quiz,
                exam_data: data.exam
            }]);
        }

        res.json(data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// --- GENERATE MORE QUIZ ---
app.post('/api/generate-more-quiz', async (req, res) => {
    const { documentContent, title, existingQuestions = [], count = 5 } = req.body;
    try {
        const prompt = `Based on "${title}", generate ${count} additional quiz questions. Avoid: ${existingQuestions.join(' | ')}. Return ONLY JSON array.`;
        const completion = await groq.chat.completions.create({
            messages: [{ role: "system", content: "JSON-only bot." }, { role: "user", content: prompt }],
            model: "llama-3.3-70b-versatile",
            temperature: 0.4,
            max_tokens: 3000,
        });
        const repaired = repairJSON(completion.choices[0]?.message?.content || "[]");
        res.json(JSON.parse(repaired));
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// --- GENERATE MORE EXAM ---
app.post('/api/generate-more-exam', async (req, res) => {
    const { documentContent, title, existingQuestions = [], count = 5 } = req.body;
    try {
        const prompt = `Based on "${title}", generate ${count} additional exam questions. Avoid: ${existingQuestions.join(' | ')}. Return ONLY JSON array.`;
        const completion = await groq.chat.completions.create({
            messages: [{ role: "system", content: "JSON-only bot." }, { role: "user", content: prompt }],
            model: "llama-3.3-70b-versatile",
            temperature: 0.4,
            max_tokens: 3000,
        });
        const repaired = repairJSON(completion.choices[0]?.message?.content || "[]");
        res.json(JSON.parse(repaired));
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// (Rest of the file follows standard Express/Socket setup...)
// For brevity, I'll only replace the relevant parts using specific replacement or I'll just rewrite if it's easier.
// Since the file is large, I'll provide the specific replacements next.
